<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>Mcp320x: MCP320x&lt; ChannelType &gt; Class Template Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Mcp320x
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="classes.html"><span>Data&#160;Structure&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#pub-types">Public Types</a> &#124;
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="#pri-types">Private Types</a> &#124;
<a href="#pri-methods">Private Member Functions</a> &#124;
<a href="#pri-static-methods">Static Private Member Functions</a> &#124;
<a href="#pri-attribs">Private Attributes</a>  </div>
  <div class="headertitle">
<div class="title">MCP320x&lt; ChannelType &gt; Class Template Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="_mcp320x_8h_source.html">Mcp320x.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">union &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="union_m_c_p320x_1_1_spi_data.html">SpiData</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-types"></a>
Public Types</h2></td></tr>
<tr class="memitem:abf242085bc0e5a3eefb57509c92d5100"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_p320x.html#abf242085bc0e5a3eefb57509c92d5100">Channel</a> = ChannelType</td></tr>
<tr class="separator:abf242085bc0e5a3eefb57509c92d5100"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a8983643c681ce83e6d40c7335822eeed"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_p320x.html#a8983643c681ce83e6d40c7335822eeed">MCP320x</a> (uint16_t vref, uint8_t csPin, SPIClass *spi)</td></tr>
<tr class="separator:a8983643c681ce83e6d40c7335822eeed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d3b38d9c274bea4f4681c895e90a2f9"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_p320x.html#a6d3b38d9c274bea4f4681c895e90a2f9">MCP320x</a> (uint16_t vref, uint8_t csPin)</td></tr>
<tr class="separator:a6d3b38d9c274bea4f4681c895e90a2f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa27b5323a647b8db907b90ec61818147"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_p320x.html#aa27b5323a647b8db907b90ec61818147">calibrate</a> (<a class="el" href="class_m_c_p320x.html#abf242085bc0e5a3eefb57509c92d5100">Channel</a> ch)</td></tr>
<tr class="separator:aa27b5323a647b8db907b90ec61818147"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a960e1419a66c9c7ffa27e79795149e84"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_p320x.html#a960e1419a66c9c7ffa27e79795149e84">read</a> (<a class="el" href="class_m_c_p320x.html#abf242085bc0e5a3eefb57509c92d5100">Channel</a> ch) const </td></tr>
<tr class="separator:a960e1419a66c9c7ffa27e79795149e84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a59a151be128777e1f49ec39accb920fd"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:a59a151be128777e1f49ec39accb920fd"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_m_c_p320x.html#a59a151be128777e1f49ec39accb920fd">read</a> (<a class="el" href="class_m_c_p320x.html#abf242085bc0e5a3eefb57509c92d5100">Channel</a> ch, T(&amp;data)[N]) const </td></tr>
<tr class="separator:a59a151be128777e1f49ec39accb920fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a35c61c9b1cc76399a841da45574d5340"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N&gt; </td></tr>
<tr class="memitem:a35c61c9b1cc76399a841da45574d5340"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_m_c_p320x.html#a35c61c9b1cc76399a841da45574d5340">read</a> (<a class="el" href="class_m_c_p320x.html#abf242085bc0e5a3eefb57509c92d5100">Channel</a> ch, T(&amp;data)[N], uint32_t splFreq)</td></tr>
<tr class="separator:a35c61c9b1cc76399a841da45574d5340"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aef9fb43edee98b61a676d8d1fd0c4082"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N, typename Predicate &gt; </td></tr>
<tr class="memitem:aef9fb43edee98b61a676d8d1fd0c4082"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_m_c_p320x.html#aef9fb43edee98b61a676d8d1fd0c4082">read_if</a> (<a class="el" href="class_m_c_p320x.html#abf242085bc0e5a3eefb57509c92d5100">Channel</a> ch, T(&amp;data)[N], Predicate p) const </td></tr>
<tr class="separator:aef9fb43edee98b61a676d8d1fd0c4082"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b37a16c3bc6531913e7a73628835492"><td class="memTemplParams" colspan="2">template&lt;typename T , size_t N, typename Predicate &gt; </td></tr>
<tr class="memitem:a9b37a16c3bc6531913e7a73628835492"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_m_c_p320x.html#a9b37a16c3bc6531913e7a73628835492">read_if</a> (<a class="el" href="class_m_c_p320x.html#abf242085bc0e5a3eefb57509c92d5100">Channel</a> ch, T(&amp;data)[N], uint32_t splFreq, Predicate p)</td></tr>
<tr class="separator:a9b37a16c3bc6531913e7a73628835492"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80998dd14486deb776128e8a62015fc6"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a80998dd14486deb776128e8a62015fc6"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_m_c_p320x.html#a80998dd14486deb776128e8a62015fc6">readn</a> (<a class="el" href="class_m_c_p320x.html#abf242085bc0e5a3eefb57509c92d5100">Channel</a> ch, T *data, uint16_t num) const </td></tr>
<tr class="separator:a80998dd14486deb776128e8a62015fc6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6d66245ecaac29bdbcaf82f30b8fc555"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a6d66245ecaac29bdbcaf82f30b8fc555"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_m_c_p320x.html#a6d66245ecaac29bdbcaf82f30b8fc555">readn</a> (<a class="el" href="class_m_c_p320x.html#abf242085bc0e5a3eefb57509c92d5100">Channel</a> ch, T *data, uint16_t num, uint32_t splFreq)</td></tr>
<tr class="separator:a6d66245ecaac29bdbcaf82f30b8fc555"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab80db5b6efae54356341477b38c26fca"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Predicate &gt; </td></tr>
<tr class="memitem:ab80db5b6efae54356341477b38c26fca"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_m_c_p320x.html#ab80db5b6efae54356341477b38c26fca">readn_if</a> (<a class="el" href="class_m_c_p320x.html#abf242085bc0e5a3eefb57509c92d5100">Channel</a> ch, T *data, uint16_t num, Predicate p) const </td></tr>
<tr class="separator:ab80db5b6efae54356341477b38c26fca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0344678629b41936f119e864b3003de"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Predicate &gt; </td></tr>
<tr class="memitem:ac0344678629b41936f119e864b3003de"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_m_c_p320x.html#ac0344678629b41936f119e864b3003de">readn_if</a> (<a class="el" href="class_m_c_p320x.html#abf242085bc0e5a3eefb57509c92d5100">Channel</a> ch, T *data, uint16_t num, uint32_t splFreq, Predicate p)</td></tr>
<tr class="separator:ac0344678629b41936f119e864b3003de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1159e8163c7da69207bf806caabfc5a"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_p320x.html#af1159e8163c7da69207bf806caabfc5a">testSplSpeed</a> (<a class="el" href="class_m_c_p320x.html#abf242085bc0e5a3eefb57509c92d5100">Channel</a> ch) const </td></tr>
<tr class="separator:af1159e8163c7da69207bf806caabfc5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1e9c6b549b9acda38f934b2a92ba688d"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_p320x.html#a1e9c6b549b9acda38f934b2a92ba688d">testSplSpeed</a> (<a class="el" href="class_m_c_p320x.html#abf242085bc0e5a3eefb57509c92d5100">Channel</a> ch, uint16_t num) const </td></tr>
<tr class="separator:a1e9c6b549b9acda38f934b2a92ba688d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8daf584c9562db3368108a8f74a93ef"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_p320x.html#ac8daf584c9562db3368108a8f74a93ef">testSplSpeed</a> (<a class="el" href="class_m_c_p320x.html#abf242085bc0e5a3eefb57509c92d5100">Channel</a> ch, uint16_t num, uint32_t splFreq)</td></tr>
<tr class="separator:ac8daf584c9562db3368108a8f74a93ef"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe95c3f107ab2f576e3ac1ac7f02cb1e"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_p320x.html#abe95c3f107ab2f576e3ac1ac7f02cb1e">toAnalog</a> (uint16_t raw) const </td></tr>
<tr class="separator:abe95c3f107ab2f576e3ac1ac7f02cb1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae366f336ae9b104928d0aef82fbf5783"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_p320x.html#ae366f336ae9b104928d0aef82fbf5783">toDigital</a> (uint16_t val) const </td></tr>
<tr class="separator:ae366f336ae9b104928d0aef82fbf5783"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57bdd9b23c9348630cdd71f26c3ab086"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_p320x.html#a57bdd9b23c9348630cdd71f26c3ab086">getVref</a> () const </td></tr>
<tr class="separator:a57bdd9b23c9348630cdd71f26c3ab086"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9eb8b363ce8fea0ce79e9bb4eb4997b3"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_p320x.html#a9eb8b363ce8fea0ce79e9bb4eb4997b3">getAnalogRes</a> () const </td></tr>
<tr class="separator:a9eb8b363ce8fea0ce79e9bb4eb4997b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a7c33fc250447f88958aaf7c93f2e7fc5"><td class="memItemLeft" align="right" valign="top">static const uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_p320x.html#a7c33fc250447f88958aaf7c93f2e7fc5">kResBits</a> = 12</td></tr>
<tr class="separator:a7c33fc250447f88958aaf7c93f2e7fc5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d81489d2df98f1ff3d1f74818a15e9d"><td class="memItemLeft" align="right" valign="top">static const uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_p320x.html#a8d81489d2df98f1ff3d1f74818a15e9d">kRes</a> = (1 &lt;&lt; <a class="el" href="class_m_c_p320x.html#a7c33fc250447f88958aaf7c93f2e7fc5">kResBits</a>)</td></tr>
<tr class="separator:a8d81489d2df98f1ff3d1f74818a15e9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-types"></a>
Private Types</h2></td></tr>
<tr class="memitem:aceeb3c39f689d84c77e8e1b82e04e794"><td class="memTemplParams" colspan="2">template&lt;typename &gt; </td></tr>
<tr class="memitem:aceeb3c39f689d84c77e8e1b82e04e794"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_m_c_p320x.html#aceeb3c39f689d84c77e8e1b82e04e794">Command</a> = <a class="el" href="union_m_c_p320x_1_1_spi_data.html">SpiData</a></td></tr>
<tr class="separator:aceeb3c39f689d84c77e8e1b82e04e794"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-methods"></a>
Private Member Functions</h2></td></tr>
<tr class="memitem:a804c67e09b410e872c874e240e858a58"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_p320x.html#a804c67e09b410e872c874e240e858a58">getSplDelay</a> (<a class="el" href="class_m_c_p320x.html#abf242085bc0e5a3eefb57509c92d5100">Channel</a> ch, uint32_t splFreq)</td></tr>
<tr class="separator:a804c67e09b410e872c874e240e858a58"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9968f9c49125565e45396fb1e97a9d3d"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_p320x.html#a9968f9c49125565e45396fb1e97a9d3d">execute</a> (<a class="el" href="class_m_c_p320x.html#aceeb3c39f689d84c77e8e1b82e04e794">Command</a>&lt; <a class="el" href="class_m_c_p320x.html#abf242085bc0e5a3eefb57509c92d5100">Channel</a> &gt; cmd) const </td></tr>
<tr class="separator:a9968f9c49125565e45396fb1e97a9d3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa07f9f8b1253a82ab02668b9f846ff1f"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:aa07f9f8b1253a82ab02668b9f846ff1f"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_m_c_p320x.html#aa07f9f8b1253a82ab02668b9f846ff1f">execute</a> (<a class="el" href="class_m_c_p320x.html#aceeb3c39f689d84c77e8e1b82e04e794">Command</a>&lt; <a class="el" href="class_m_c_p320x.html#abf242085bc0e5a3eefb57509c92d5100">Channel</a> &gt; cmd, T *data, uint16_t num) const </td></tr>
<tr class="separator:aa07f9f8b1253a82ab02668b9f846ff1f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a046ea0b154acb9e2782b14f20db697d3"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a046ea0b154acb9e2782b14f20db697d3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="class_m_c_p320x.html#a046ea0b154acb9e2782b14f20db697d3">execute</a> (<a class="el" href="class_m_c_p320x.html#aceeb3c39f689d84c77e8e1b82e04e794">Command</a>&lt; <a class="el" href="class_m_c_p320x.html#abf242085bc0e5a3eefb57509c92d5100">Channel</a> &gt; cmd, T *data, uint16_t num, uint16_t delay) const </td></tr>
<tr class="separator:a046ea0b154acb9e2782b14f20db697d3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa879ecb754029db974d0bec35ebe81ce"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_p320x.html#aa879ecb754029db974d0bec35ebe81ce">transfer</a> () const </td></tr>
<tr class="separator:aa879ecb754029db974d0bec35ebe81ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00d3fe5a82cc6550910957c141f101b7"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_p320x.html#a00d3fe5a82cc6550910957c141f101b7">transfer</a> (<a class="el" href="union_m_c_p320x_1_1_spi_data.html">SpiData</a> cmd) const </td></tr>
<tr class="separator:a00d3fe5a82cc6550910957c141f101b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-static-methods"></a>
Static Private Member Functions</h2></td></tr>
<tr class="memitem:abab1da3525e087a0b75b485e61a99204"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="class_m_c_p320x.html#aceeb3c39f689d84c77e8e1b82e04e794">Command</a>&lt; <a class="el" href="class_m_c_p320x.html#abf242085bc0e5a3eefb57509c92d5100">Channel</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_p320x.html#abab1da3525e087a0b75b485e61a99204">createCmd</a> (<a class="el" href="class_m_c_p320x.html#abf242085bc0e5a3eefb57509c92d5100">Channel</a> ch)</td></tr>
<tr class="separator:abab1da3525e087a0b75b485e61a99204"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pri-attribs"></a>
Private Attributes</h2></td></tr>
<tr class="memitem:aa10a9412651376dfe4c9d13e9313b87b"><td class="memItemLeft" align="right" valign="top">uint16_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_p320x.html#aa10a9412651376dfe4c9d13e9313b87b">mVref</a></td></tr>
<tr class="separator:aa10a9412651376dfe4c9d13e9313b87b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a671949f5a580f19008c8bdb96a0f714c"><td class="memItemLeft" align="right" valign="top">uint8_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_p320x.html#a671949f5a580f19008c8bdb96a0f714c">mCsPin</a></td></tr>
<tr class="separator:a671949f5a580f19008c8bdb96a0f714c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a870d36c6693fe7164f16ad0a29faa61c"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_p320x.html#a870d36c6693fe7164f16ad0a29faa61c">mSplSpeed</a></td></tr>
<tr class="separator:a870d36c6693fe7164f16ad0a29faa61c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7735e749b8c4757b0679a4c8763cf47e"><td class="memItemLeft" align="right" valign="top">SPIClass *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_m_c_p320x.html#a7735e749b8c4757b0679a4c8763cf47e">mSpi</a></td></tr>
<tr class="separator:a7735e749b8c4757b0679a4c8763cf47e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><h3>template&lt;typename ChannelType&gt;<br />
class MCP320x&lt; ChannelType &gt;</h3>


<p>Definition at line <a class="el" href="_mcp320x_8h_source.html#l00115">115</a> of file <a class="el" href="_mcp320x_8h_source.html">Mcp320x.h</a>.</p>
</div><h2 class="groupheader">Member Typedef Documentation</h2>
<a class="anchor" id="abf242085bc0e5a3eefb57509c92d5100"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChannelType &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_m_c_p320x.html">MCP320x</a>&lt; ChannelType &gt;::<a class="el" href="class_m_c_p320x.html#abf242085bc0e5a3eefb57509c92d5100">Channel</a> =  ChannelType</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>ADC Channel configuration. </p>

<p>Definition at line <a class="el" href="_mcp320x_8h_source.html#l00125">125</a> of file <a class="el" href="_mcp320x_8h_source.html">Mcp320x.h</a>.</p>

</div>
</div>
<a class="anchor" id="aceeb3c39f689d84c77e8e1b82e04e794"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChannelType &gt; </div>
<div class="memtemplate">
template&lt;typename &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="class_m_c_p320x.html">MCP320x</a>&lt; ChannelType &gt;::<a class="el" href="class_m_c_p320x.html#aceeb3c39f689d84c77e8e1b82e04e794">Command</a> =  <a class="el" href="union_m_c_p320x_1_1_spi_data.html">SpiData</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>SPI command for a specific channel type. </p>

<p>Definition at line <a class="el" href="_mcp320x_8h_source.html#l00375">375</a> of file <a class="el" href="_mcp320x_8h_source.html">Mcp320x.h</a>.</p>

</div>
</div>
<h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a8983643c681ce83e6d40c7335822eeed"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_c_p320x.html">MCP320x</a>&lt; T &gt;::<a class="el" href="class_m_c_p320x.html">MCP320x</a> </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>vref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>csPin</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SPIClass *&#160;</td>
          <td class="paramname"><em>spi</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initiates a <a class="el" href="class_m_c_p320x.html">MCP320x</a> object. The chip select pin must be already configured as output. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vref</td><td>ADC reference voltage in mV. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">csPin</td><td>pin number to use for chip select. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">spi</td><td>reference to the SPI interface to use. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_mcp320x_8cpp_source.html#l00017">17</a> of file <a class="el" href="_mcp320x_8cpp_source.html">Mcp320x.cpp</a>.</p>

</div>
</div>
<a class="anchor" id="a6d3b38d9c274bea4f4681c895e90a2f9"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_c_p320x.html">MCP320x</a>&lt; T &gt;::<a class="el" href="class_m_c_p320x.html">MCP320x</a> </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>vref</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>csPin</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initiates a <a class="el" href="class_m_c_p320x.html">MCP320x</a> object. The chip select pin must be already configured as output. The default SPI interface will be used for communication. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vref</td><td>the ADC reference voltage in mV. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">csPin</td><td>the pin number to use for chip select. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_mcp320x_8cpp_source.html#l00024">24</a> of file <a class="el" href="_mcp320x_8cpp_source.html">Mcp320x.cpp</a>.</p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aa27b5323a647b8db907b90ec61818147"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_m_c_p320x.html">MCP320x</a>&lt; T &gt;::calibrate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_c_p320x.html#abf242085bc0e5a3eefb57509c92d5100">Channel</a>&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calibrates read timing using the supplied channel. A calibration should be performed after evey SPI frequency changes or other events that could have an impact on the sampling speed. The SPI interface must be initialized and put in a usable state before calling this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ch</td><td>defines the channel to use for calibration. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_mcp320x_8cpp_source.html#l00028">28</a> of file <a class="el" href="_mcp320x_8cpp_source.html">Mcp320x.cpp</a>.</p>

<p>References <a class="el" href="_mcp320x_8h_source.html#l00449">MCP320x&lt; ChannelType &gt;::mSplSpeed</a>, and <a class="el" href="_mcp320x_8cpp_source.html#l00040">MCP320x&lt; ChannelType &gt;::testSplSpeed()</a>.</p>

<p>Referenced by <a class="el" href="_mcp320x_8cpp_source.html#l00106">MCP320x&lt; ChannelType &gt;::getSplDelay()</a>.</p>

</div>
</div>
<a class="anchor" id="abab1da3525e087a0b75b485e61a99204"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_m_c_p320x.html#aceeb3c39f689d84c77e8e1b82e04e794">MCP3208::Command</a>&lt; <a class="el" href="_mcp320x_8cpp.html#a770497aa4aa61469777c6ea10fdb91ac">MCP3208Ch</a> &gt; MCP3208::createCmd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_c_p320x.html#abf242085bc0e5a3eefb57509c92d5100">Channel</a>&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a command from the supplied channel. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ch</td><td>the channel to create the command for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the SPI data. </dd></dl>

<p>Definition at line <a class="el" href="_mcp320x_8cpp_source.html#l00120">120</a> of file <a class="el" href="_mcp320x_8cpp_source.html">Mcp320x.cpp</a>.</p>

<p>Referenced by <a class="el" href="_mcp320x_8cpp_source.html#l00034">MCP320x&lt; ChannelType &gt;::read()</a>, and <a class="el" href="_mcp320x_8cpp_source.html#l00046">MCP320x&lt; ChannelType &gt;::testSplSpeed()</a>.</p>

</div>
</div>
<a class="anchor" id="a9968f9c49125565e45396fb1e97a9d3d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t MCP3208::execute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_c_p320x.html#aceeb3c39f689d84c77e8e1b82e04e794">Command</a>&lt; <a class="el" href="class_m_c_p320x.html#abf242085bc0e5a3eefb57509c92d5100">Channel</a> &gt;&#160;</td>
          <td class="paramname"><em>cmd</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Executes the supplied command. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>the command to execute. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the ADC value from the SPI response. </dd></dl>

<p>Definition at line <a class="el" href="_mcp320x_8cpp_source.html#l00163">163</a> of file <a class="el" href="_mcp320x_8cpp_source.html">Mcp320x.cpp</a>.</p>

<p>References <a class="el" href="_mcp320x_8cpp_source.html#l00187">MCP320x&lt; ChannelType &gt;::transfer()</a>.</p>

<p>Referenced by <a class="el" href="_mcp320x_8cpp_source.html#l00034">MCP320x&lt; ChannelType &gt;::read()</a>, and <a class="el" href="_mcp320x_8cpp_source.html#l00046">MCP320x&lt; ChannelType &gt;::testSplSpeed()</a>.</p>

</div>
</div>
<a class="anchor" id="aa07f9f8b1253a82ab02668b9f846ff1f"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChannelType &gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_m_c_p320x.html">MCP320x</a>&lt; ChannelType &gt;::execute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_c_p320x.html#aceeb3c39f689d84c77e8e1b82e04e794">Command</a>&lt; <a class="el" href="class_m_c_p320x.html#abf242085bc0e5a3eefb57509c92d5100">Channel</a> &gt;&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Executes the supplied command for the requested number of samples. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>the command to execute. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>array to store the values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num</td><td>number of reads. The data array needs to be at least that size. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_mcp320x_8h_source.html#l00407">407</a> of file <a class="el" href="_mcp320x_8h_source.html">Mcp320x.h</a>.</p>

</div>
</div>
<a class="anchor" id="a046ea0b154acb9e2782b14f20db697d3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChannelType &gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_m_c_p320x.html">MCP320x</a>&lt; ChannelType &gt;::execute </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_c_p320x.html#aceeb3c39f689d84c77e8e1b82e04e794">Command</a>&lt; <a class="el" href="class_m_c_p320x.html#abf242085bc0e5a3eefb57509c92d5100">Channel</a> &gt;&#160;</td>
          <td class="paramname"><em>cmd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>delay</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Executes the supplied command for the requested number of samples with delay between reads. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>the command to execute. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>array to store the values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num</td><td>number of reads. The data array needs to be at least that size. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">delay</td><td>in us. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_mcp320x_8h_source.html#l00423">423</a> of file <a class="el" href="_mcp320x_8h_source.html">Mcp320x.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9eb8b363ce8fea0ce79e9bb4eb4997b3"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uint16_t <a class="el" href="class_m_c_p320x.html">MCP320x</a>&lt; T &gt;::getAnalogRes </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the analog resolution in µV based on the defined reference voltage. </p><dl class="section return"><dt>Returns</dt><dd>the analog resolution in µV. </dd></dl>

<p>Definition at line <a class="el" href="_mcp320x_8cpp_source.html#l00100">100</a> of file <a class="el" href="_mcp320x_8cpp_source.html">Mcp320x.cpp</a>.</p>

<p>References <a class="el" href="_mcp320x_8h_source.html#l00122">MCP320x&lt; ChannelType &gt;::kRes</a>, and <a class="el" href="_mcp320x_8h_source.html#l00447">MCP320x&lt; ChannelType &gt;::mVref</a>.</p>

</div>
</div>
<a class="anchor" id="a804c67e09b410e872c874e240e858a58"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t <a class="el" href="class_m_c_p320x.html">MCP320x</a>&lt; T &gt;::getSplDelay </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_c_p320x.html#abf242085bc0e5a3eefb57509c92d5100">Channel</a>&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>splFreq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the required delay for the requested sample rate. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ch</td><td>the channel to create the command for. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the delay in us. </dd></dl>

<p>Definition at line <a class="el" href="_mcp320x_8cpp_source.html#l00106">106</a> of file <a class="el" href="_mcp320x_8cpp_source.html">Mcp320x.cpp</a>.</p>

<p>References <a class="el" href="_mcp320x_8cpp_source.html#l00028">MCP320x&lt; ChannelType &gt;::calibrate()</a>, <a class="el" href="_mcp320x_8cpp_source.html#l00008">div_round</a>, and <a class="el" href="_mcp320x_8h_source.html#l00449">MCP320x&lt; ChannelType &gt;::mSplSpeed</a>.</p>

<p>Referenced by <a class="el" href="_mcp320x_8cpp_source.html#l00061">MCP320x&lt; ChannelType &gt;::testSplSpeed()</a>.</p>

</div>
</div>
<a class="anchor" id="a57bdd9b23c9348630cdd71f26c3ab086"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uint16_t <a class="el" href="class_m_c_p320x.html">MCP320x</a>&lt; T &gt;::getVref </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns the reference voltage. </p><dl class="section return"><dt>Returns</dt><dd>the configured reference voltage in mV. </dd></dl>

<p>Definition at line <a class="el" href="_mcp320x_8cpp_source.html#l00094">94</a> of file <a class="el" href="_mcp320x_8cpp_source.html">Mcp320x.cpp</a>.</p>

<p>References <a class="el" href="_mcp320x_8h_source.html#l00447">MCP320x&lt; ChannelType &gt;::mVref</a>.</p>

</div>
</div>
<a class="anchor" id="a960e1419a66c9c7ffa27e79795149e84"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uint16_t <a class="el" href="class_m_c_p320x.html">MCP320x</a>&lt; T &gt;::read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_c_p320x.html#abf242085bc0e5a3eefb57509c92d5100">Channel</a>&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Reads the supplied channel. The SPI interface must be initialized and put in a usable state before calling this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ch</td><td>defines the channel to read from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the converted raw value. </dd></dl>

<p>Definition at line <a class="el" href="_mcp320x_8cpp_source.html#l00034">34</a> of file <a class="el" href="_mcp320x_8cpp_source.html">Mcp320x.cpp</a>.</p>

<p>References <a class="el" href="_mcp320x_8cpp_source.html#l00120">MCP320x&lt; ChannelType &gt;::createCmd()</a>, and <a class="el" href="_mcp320x_8cpp_source.html#l00163">MCP320x&lt; ChannelType &gt;::execute()</a>.</p>

</div>
</div>
<a class="anchor" id="a59a151be128777e1f49ec39accb920fd"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChannelType &gt; </div>
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_m_c_p320x.html">MCP320x</a>&lt; ChannelType &gt;::read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_c_p320x.html#abf242085bc0e5a3eefb57509c92d5100">Channel</a>&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>data</em>[N]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reads the supplied channel and stores the data in the supplied data array. The SPI interface must be initialized and put in a usable state before calling this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ch</td><td>defines the channel to read from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>array to store the values. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_mcp320x_8h_source.html#l00171">171</a> of file <a class="el" href="_mcp320x_8h_source.html">Mcp320x.h</a>.</p>

</div>
</div>
<a class="anchor" id="a35c61c9b1cc76399a841da45574d5340"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChannelType &gt; </div>
<div class="memtemplate">
template&lt;typename T , size_t N&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_m_c_p320x.html">MCP320x</a>&lt; ChannelType &gt;::read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_c_p320x.html#abf242085bc0e5a3eefb57509c92d5100">Channel</a>&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>data</em>[N], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>splFreq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reads the supplied channel limited to the specified frequency and stores the data in the supplied data array. The sample rate limit is software controlled, and has a low precision. The SPI interface must be initialized and put in a usable state before calling this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ch</td><td>defines the channel to read from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>array to store the values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">splFreq</td><td>sample frequency limit in hz. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_mcp320x_8h_source.html#l00187">187</a> of file <a class="el" href="_mcp320x_8h_source.html">Mcp320x.h</a>.</p>

</div>
</div>
<a class="anchor" id="aef9fb43edee98b61a676d8d1fd0c4082"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChannelType &gt; </div>
<div class="memtemplate">
template&lt;typename T , size_t N, typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_m_c_p320x.html">MCP320x</a>&lt; ChannelType &gt;::read_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_c_p320x.html#abf242085bc0e5a3eefb57509c92d5100">Channel</a>&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>data</em>[N], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reads the supplied channel and stores the data in the supplied data array after the predicate is true. The SPI interface must be initialized and put in a usable state before calling this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ch</td><td>defines the channel to read from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>array to store the values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>predicate funtion to control sampling start. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_mcp320x_8h_source.html#l00201">201</a> of file <a class="el" href="_mcp320x_8h_source.html">Mcp320x.h</a>.</p>

</div>
</div>
<a class="anchor" id="a9b37a16c3bc6531913e7a73628835492"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChannelType &gt; </div>
<div class="memtemplate">
template&lt;typename T , size_t N, typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_m_c_p320x.html">MCP320x</a>&lt; ChannelType &gt;::read_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_c_p320x.html#abf242085bc0e5a3eefb57509c92d5100">Channel</a>&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T(&amp;)&#160;</td>
          <td class="paramname"><em>data</em>[N], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>splFreq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reads the supplied channel limited to the specified frequency and stores the data in the supplied data array after the predicate is true. The sample rate limit is software controlled, and has a low precision. The SPI interface must be initialized and put in a usable state before calling this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ch</td><td>defines the channel to read from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>array to store the values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">splFreq</td><td>sample frequency limit in hz. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>predicate funtion to control sampling start. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_mcp320x_8h_source.html#l00218">218</a> of file <a class="el" href="_mcp320x_8h_source.html">Mcp320x.h</a>.</p>

</div>
</div>
<a class="anchor" id="a80998dd14486deb776128e8a62015fc6"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChannelType &gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_m_c_p320x.html">MCP320x</a>&lt; ChannelType &gt;::readn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_c_p320x.html#abf242085bc0e5a3eefb57509c92d5100">Channel</a>&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reads the supplied channel and stores N values in the supplied data array. The SPI interface must be initialized and put in a usable state before calling this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ch</td><td>defines the channel to read from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>array to store the values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num</td><td>number of reads. The data array needs to be at least that size. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_mcp320x_8h_source.html#l00233">233</a> of file <a class="el" href="_mcp320x_8h_source.html">Mcp320x.h</a>.</p>

</div>
</div>
<a class="anchor" id="a6d66245ecaac29bdbcaf82f30b8fc555"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChannelType &gt; </div>
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_m_c_p320x.html">MCP320x</a>&lt; ChannelType &gt;::readn </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_c_p320x.html#abf242085bc0e5a3eefb57509c92d5100">Channel</a>&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>splFreq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reads the supplied channel limited to the specified frequency and stores N values in the supplied data array. The sample rate limit is software controlled, and has a low precision. The SPI interface must be initialized and put in a usable state before calling this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ch</td><td>defines the channel to read from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>array to store the values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num</td><td>number of reads. The data array needs to be at least that size. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">splFreq</td><td>sample frequency limit in hz. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_mcp320x_8h_source.html#l00251">251</a> of file <a class="el" href="_mcp320x_8h_source.html">Mcp320x.h</a>.</p>

</div>
</div>
<a class="anchor" id="ab80db5b6efae54356341477b38c26fca"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChannelType &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_m_c_p320x.html">MCP320x</a>&lt; ChannelType &gt;::readn_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_c_p320x.html#abf242085bc0e5a3eefb57509c92d5100">Channel</a>&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reads the supplied channel and stores N values in the supplied data array after the predicate is true. As long as the predicate is false, the function keeps sampling without storing any data. The SPI interface must be initialized and put in a usable state before calling this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ch</td><td>defines the channel to read from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>array to store the values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num</td><td>number of reads. The data array needs to be at least that size. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>predicate funtion to control sampling start. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_mcp320x_8h_source.html#l00269">269</a> of file <a class="el" href="_mcp320x_8h_source.html">Mcp320x.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac0344678629b41936f119e864b3003de"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChannelType &gt; </div>
<div class="memtemplate">
template&lt;typename T , typename Predicate &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void <a class="el" href="class_m_c_p320x.html">MCP320x</a>&lt; ChannelType &gt;::readn_if </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_c_p320x.html#abf242085bc0e5a3eefb57509c92d5100">Channel</a>&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>splFreq</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Predicate&#160;</td>
          <td class="paramname"><em>p</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Reads the supplied channel limited to the specified frequency and stores N values in the supplied data array after the predicate is true. As long as the predicate is false, the function keeps sampling without storing any data. The SPI interface must be initialized and put in a usable state before calling this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ch</td><td>defines the channel to read from. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">data</td><td>array to store the values. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num</td><td>number of reads. The data array needs to be at least that size. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">splFreq</td><td>sample frequency limit in hz. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">p</td><td>predicate funtion to control sampling start. </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="_mcp320x_8h_source.html#l00291">291</a> of file <a class="el" href="_mcp320x_8h_source.html">Mcp320x.h</a>.</p>

</div>
</div>
<a class="anchor" id="af1159e8163c7da69207bf806caabfc5a"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="class_m_c_p320x.html">MCP320x</a>&lt; T &gt;::testSplSpeed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_c_p320x.html#abf242085bc0e5a3eefb57509c92d5100">Channel</a>&#160;</td>
          <td class="paramname"><em>ch</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs a sampling speed test over 64 reads. The SPI interface must be initialized and put in a usable state before calling this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ch</td><td>the channel to use for the speed test. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the average sampling time needed for one sample in ns. </dd></dl>

<p>Definition at line <a class="el" href="_mcp320x_8cpp_source.html#l00040">40</a> of file <a class="el" href="_mcp320x_8cpp_source.html">Mcp320x.cpp</a>.</p>

<p>Referenced by <a class="el" href="_mcp320x_8cpp_source.html#l00028">MCP320x&lt; ChannelType &gt;::calibrate()</a>.</p>

</div>
</div>
<a class="anchor" id="a1e9c6b549b9acda38f934b2a92ba688d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="class_m_c_p320x.html">MCP320x</a>&lt; T &gt;::testSplSpeed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_c_p320x.html#abf242085bc0e5a3eefb57509c92d5100">Channel</a>&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>num</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs a sampling speed test. The SPI interface must be initialized and put in a usable state before calling this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ch</td><td>the channel to use for the speed test. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num</td><td>the number of reads to perform. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the average sampling time needed for one sample in ns. </dd></dl>

<p>Definition at line <a class="el" href="_mcp320x_8cpp_source.html#l00046">46</a> of file <a class="el" href="_mcp320x_8cpp_source.html">Mcp320x.cpp</a>.</p>

<p>References <a class="el" href="_mcp320x_8cpp_source.html#l00120">MCP320x&lt; ChannelType &gt;::createCmd()</a>, <a class="el" href="_mcp320x_8cpp_source.html#l00008">div_round</a>, and <a class="el" href="_mcp320x_8cpp_source.html#l00163">MCP320x&lt; ChannelType &gt;::execute()</a>.</p>

</div>
</div>
<a class="anchor" id="ac8daf584c9562db3368108a8f74a93ef"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="class_m_c_p320x.html">MCP320x</a>&lt; T &gt;::testSplSpeed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_m_c_p320x.html#abf242085bc0e5a3eefb57509c92d5100">Channel</a>&#160;</td>
          <td class="paramname"><em>ch</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>num</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>splFreq</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Performs a sampling speed test limited to the specified frequency. The SPI interface must be initialized and put in a usable state before calling this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ch</td><td>the channel to use for the speed test. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">num</td><td>the number of reads to perform. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">splFreq</td><td>sample frequency limit in hz. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the average sampling time needed for one sample in ns. </dd></dl>

<p>Definition at line <a class="el" href="_mcp320x_8cpp_source.html#l00061">61</a> of file <a class="el" href="_mcp320x_8cpp_source.html">Mcp320x.cpp</a>.</p>

<p>References <a class="el" href="_mcp320x_8cpp_source.html#l00120">MCP320x&lt; ChannelType &gt;::createCmd()</a>, <a class="el" href="_mcp320x_8cpp_source.html#l00008">div_round</a>, <a class="el" href="_mcp320x_8cpp_source.html#l00163">MCP320x&lt; ChannelType &gt;::execute()</a>, and <a class="el" href="_mcp320x_8cpp_source.html#l00106">MCP320x&lt; ChannelType &gt;::getSplDelay()</a>.</p>

</div>
</div>
<a class="anchor" id="abe95c3f107ab2f576e3ac1ac7f02cb1e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uint16_t <a class="el" href="class_m_c_p320x.html">MCP320x</a>&lt; T &gt;::toAnalog </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>raw</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts the supplied raw value to an analog value in mV based on the defined reference voltage. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">raw</td><td>the sampled ADC value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the converted analog value in mV. </dd></dl>

<p>Definition at line <a class="el" href="_mcp320x_8cpp_source.html#l00082">82</a> of file <a class="el" href="_mcp320x_8cpp_source.html">Mcp320x.cpp</a>.</p>

<p>References <a class="el" href="_mcp320x_8h_source.html#l00122">MCP320x&lt; ChannelType &gt;::kRes</a>, and <a class="el" href="_mcp320x_8h_source.html#l00447">MCP320x&lt; ChannelType &gt;::mVref</a>.</p>

</div>
</div>
<a class="anchor" id="ae366f336ae9b104928d0aef82fbf5783"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">uint16_t <a class="el" href="class_m_c_p320x.html">MCP320x</a>&lt; T &gt;::toDigital </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>val</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Converts the supplied analog value to the digital representation based on the defined reference voltage. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">val</td><td>the analog value in mV. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the digital representation off the supplied analog value. </dd></dl>

<p>Definition at line <a class="el" href="_mcp320x_8cpp_source.html#l00088">88</a> of file <a class="el" href="_mcp320x_8cpp_source.html">Mcp320x.cpp</a>.</p>

<p>References <a class="el" href="_mcp320x_8h_source.html#l00122">MCP320x&lt; ChannelType &gt;::kRes</a>, and <a class="el" href="_mcp320x_8h_source.html#l00447">MCP320x&lt; ChannelType &gt;::mVref</a>.</p>

</div>
</div>
<a class="anchor" id="aa879ecb754029db974d0bec35ebe81ce"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t <a class="el" href="class_m_c_p320x.html">MCP320x</a>&lt; T &gt;::transfer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Transfers without SPI command data. </p><dl class="section return"><dt>Returns</dt><dd>the ADC value from the SPI response. </dd></dl>

<p>Definition at line <a class="el" href="_mcp320x_8cpp_source.html#l00187">187</a> of file <a class="el" href="_mcp320x_8cpp_source.html">Mcp320x.cpp</a>.</p>

<p>References <a class="el" href="_mcp320x_8h_source.html#l00367">MCP320x&lt; ChannelType &gt;::SpiData::hiByte</a>, <a class="el" href="_mcp320x_8h_source.html#l00366">MCP320x&lt; ChannelType &gt;::SpiData::loByte</a>, <a class="el" href="_mcp320x_8h_source.html#l00448">MCP320x&lt; ChannelType &gt;::mCsPin</a>, <a class="el" href="_mcp320x_8h_source.html#l00450">MCP320x&lt; ChannelType &gt;::mSpi</a>, and <a class="el" href="_mcp320x_8h_source.html#l00364">MCP320x&lt; ChannelType &gt;::SpiData::value</a>.</p>

<p>Referenced by <a class="el" href="_mcp320x_8cpp_source.html#l00163">MCP320x&lt; ChannelType &gt;::execute()</a>.</p>

</div>
</div>
<a class="anchor" id="a00d3fe5a82cc6550910957c141f101b7"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t <a class="el" href="class_m_c_p320x.html">MCP320x</a>&lt; T &gt;::transfer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="union_m_c_p320x_1_1_spi_data.html">SpiData</a>&#160;</td>
          <td class="paramname"><em>cmd</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Transfers the supplied SPI command data. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">cmd</td><td>the SPI command data to transfer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the ADC value from the SPI response. </dd></dl>

<p>Definition at line <a class="el" href="_mcp320x_8cpp_source.html#l00208">208</a> of file <a class="el" href="_mcp320x_8cpp_source.html">Mcp320x.cpp</a>.</p>

<p>References <a class="el" href="_mcp320x_8h_source.html#l00367">MCP320x&lt; ChannelType &gt;::SpiData::hiByte</a>, <a class="el" href="_mcp320x_8h_source.html#l00366">MCP320x&lt; ChannelType &gt;::SpiData::loByte</a>, <a class="el" href="_mcp320x_8h_source.html#l00448">MCP320x&lt; ChannelType &gt;::mCsPin</a>, <a class="el" href="_mcp320x_8h_source.html#l00450">MCP320x&lt; ChannelType &gt;::mSpi</a>, and <a class="el" href="_mcp320x_8h_source.html#l00364">MCP320x&lt; ChannelType &gt;::SpiData::value</a>.</p>

</div>
</div>
<h2 class="groupheader">Field Documentation</h2>
<a class="anchor" id="a8d81489d2df98f1ff3d1f74818a15e9d"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChannelType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint16_t <a class="el" href="class_m_c_p320x.html">MCP320x</a>&lt; ChannelType &gt;::kRes = (1 &lt;&lt; <a class="el" href="class_m_c_p320x.html#a7c33fc250447f88958aaf7c93f2e7fc5">kResBits</a>)</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>ADC resolution. </p>

<p>Definition at line <a class="el" href="_mcp320x_8h_source.html#l00122">122</a> of file <a class="el" href="_mcp320x_8h_source.html">Mcp320x.h</a>.</p>

<p>Referenced by <a class="el" href="_mcp320x_8cpp_source.html#l00100">MCP320x&lt; ChannelType &gt;::getAnalogRes()</a>, <a class="el" href="_mcp320x_8cpp_source.html#l00082">MCP320x&lt; ChannelType &gt;::toAnalog()</a>, and <a class="el" href="_mcp320x_8cpp_source.html#l00088">MCP320x&lt; ChannelType &gt;::toDigital()</a>.</p>

</div>
</div>
<a class="anchor" id="a7c33fc250447f88958aaf7c93f2e7fc5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChannelType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const uint8_t <a class="el" href="class_m_c_p320x.html">MCP320x</a>&lt; ChannelType &gt;::kResBits = 12</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>ADC resolution in bits. </p>

<p>Definition at line <a class="el" href="_mcp320x_8h_source.html#l00120">120</a> of file <a class="el" href="_mcp320x_8h_source.html">Mcp320x.h</a>.</p>

</div>
</div>
<a class="anchor" id="a671949f5a580f19008c8bdb96a0f714c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChannelType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint8_t <a class="el" href="class_m_c_p320x.html">MCP320x</a>&lt; ChannelType &gt;::mCsPin</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_mcp320x_8h_source.html#l00448">448</a> of file <a class="el" href="_mcp320x_8h_source.html">Mcp320x.h</a>.</p>

<p>Referenced by <a class="el" href="_mcp320x_8cpp_source.html#l00187">MCP320x&lt; ChannelType &gt;::transfer()</a>.</p>

</div>
</div>
<a class="anchor" id="a7735e749b8c4757b0679a4c8763cf47e"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChannelType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">SPIClass* <a class="el" href="class_m_c_p320x.html">MCP320x</a>&lt; ChannelType &gt;::mSpi</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_mcp320x_8h_source.html#l00450">450</a> of file <a class="el" href="_mcp320x_8h_source.html">Mcp320x.h</a>.</p>

<p>Referenced by <a class="el" href="_mcp320x_8cpp_source.html#l00187">MCP320x&lt; ChannelType &gt;::transfer()</a>.</p>

</div>
</div>
<a class="anchor" id="a870d36c6693fe7164f16ad0a29faa61c"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChannelType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t <a class="el" href="class_m_c_p320x.html">MCP320x</a>&lt; ChannelType &gt;::mSplSpeed</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_mcp320x_8h_source.html#l00449">449</a> of file <a class="el" href="_mcp320x_8h_source.html">Mcp320x.h</a>.</p>

<p>Referenced by <a class="el" href="_mcp320x_8cpp_source.html#l00028">MCP320x&lt; ChannelType &gt;::calibrate()</a>, and <a class="el" href="_mcp320x_8cpp_source.html#l00106">MCP320x&lt; ChannelType &gt;::getSplDelay()</a>.</p>

</div>
</div>
<a class="anchor" id="aa10a9412651376dfe4c9d13e9313b87b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename ChannelType &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">uint16_t <a class="el" href="class_m_c_p320x.html">MCP320x</a>&lt; ChannelType &gt;::mVref</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">private</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="_mcp320x_8h_source.html#l00447">447</a> of file <a class="el" href="_mcp320x_8h_source.html">Mcp320x.h</a>.</p>

<p>Referenced by <a class="el" href="_mcp320x_8cpp_source.html#l00100">MCP320x&lt; ChannelType &gt;::getAnalogRes()</a>, <a class="el" href="_mcp320x_8cpp_source.html#l00094">MCP320x&lt; ChannelType &gt;::getVref()</a>, <a class="el" href="_mcp320x_8cpp_source.html#l00082">MCP320x&lt; ChannelType &gt;::toAnalog()</a>, and <a class="el" href="_mcp320x_8cpp_source.html#l00088">MCP320x&lt; ChannelType &gt;::toDigital()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>src/<a class="el" href="_mcp320x_8h_source.html">Mcp320x.h</a></li>
<li>src/<a class="el" href="_mcp320x_8cpp_source.html">Mcp320x.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.11
</small></address>
</body>
</html>
